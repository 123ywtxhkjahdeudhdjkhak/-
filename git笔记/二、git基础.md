## 一、获取git仓库：

1、将未版本控制的本地目录转换为Git仓库，切换到该目录下，执行

```console
git init
```

该命令只做了初始化操作，会创建.git子目录，有git仓库所需的文件，但是本地目录中的文件还没被跟踪和提交

2、克隆一份已有仓库

```
git clone <url> [自定义目录名]
```

当使用该命令克隆一个仓库后，会自动将被克隆的仓库添加为远程仓库并以origin为服务器简写。同时会自动设置本地master分支跟踪远程master分支(看仓库的默认分支名字，一般是master)。

Git 支持多种数据传输协议，如`https://` 协议、SSH 传输协议、`git://` 协议等。

## 二、远程仓库的使用

远程仓库是一般指托管在因特网或其他网络中项目的版本库。不一定通过网络，可以是本地，只要是别处。

管理远程仓库包括：如何添加远程仓库、移除无用的远程仓库、管理不同的远程分支并定义他们是否被跟踪等等。本次只介绍一部分操作。

查看远程仓库

```
git remote //查看远程仓库
```

至少会看到origin，这是Git克隆时仓库服务器的默认别名

-v，可以显示Git保存的别名及对应的URL

如果远程仓库不止一个，该命令也会全部列出。这些仓库可能使用不同的协议，可以看服务器上的 Git-在服务器上搭建Git笔记

添加远程仓库

```
git remote add <shortname> <url>//添加一个远程的Git仓库，同时指定一个方便使用的名字简写
```

```
git remote set-url <remote_name> <new_url>//修改指定远程仓库的 URL。
```

```
git remote show <remote_name>//显示指定远程仓库的详细信息，包括 URL 和跟踪分支
```

从远程仓库中抓取与拉取

```
git fetch <服务器别名> <分支名>//访问远程仓库的某个分支，从中拉取所有本地仓库还没有的数据，执行完后，会拥有那个远程仓库的某个分支的引用，如果不指定分支，那就会拉取所有分支的引用 
```

当使用clone克隆一个仓库后，会自动将其添加为远程仓库并默认以"origin"为别名。所以git fetch origin 会抓取克隆（或上次抓取）后的所有改动。注：该命令只抓取，不会自动合并，必须手动合并，所以如果当前分支设置了跟踪远程分支，一般使用git pull抓取。可以看Git分支笔记。

远程仓库的重命名和移除

```
git remote rename 旧名 新名//修改远程仓库的服务器别名
```

```
git remote remove/rm 名字 //删除远程仓库，一旦删除，所有该仓库的远程跟踪分支及配置信息也会被删除 
```

## 三、Git中文件状态

Git工作目录下的文件有两种状态，已跟踪和未跟踪。

已跟踪文件指：Git已经知道的文件(已提交或暂存过的文件)（克隆的所有文件状态都是已跟踪），状态有已修改、未修改、已放入暂存区

未跟踪文件指：除已跟踪文件外的其他文件，这些文件不存在在上一次的快照中，也没放到暂存区，如git status -s中标记为？？？的文件。注：未跟踪的文件可以被Git检测出来，但不能被Git操作，也就是如果想要通过Git命令撤销和移除未跟踪文件是不行的，得要先将其git add才能通过Git命令执行撤销或移除操作

![](image\Snipaste_2024-10-28_15-19-09.png)

Git文件的状态变化周期

## 四、检查当前文件状态

```
git status//详细的仓库所有文件状态信息，文件状态（同一个文件可能会有多个状态，如已暂存和已修改）、当前分支、接下来可以对该文件进行的操作建议
git status -s或git status --short//简洁的仓库所有文件状态信息，？？表未跟踪，A表新文件添加到暂存区，M表文件已修改，左M表示已修改且暂存，右M表已修改未暂存，文件可处于MM表两种状态
```

## 五、将当前增加的内容添加到下一次提交里（暂存）、取消暂存

```
git add <file>//暂存文件
```

该命令可以暂存已跟踪文件、跟踪未跟踪文件、标记合并冲突文件为已解决状态

```
git reset HEAD <file><file>…//撤销文件暂存状态到已修改状态
```

也可以使用git status查看撤销命令，git reset和git restore 命令要注意使用，避免将所有文件还原到上一次提交，修改的内容全无，到Git工具-重置揭秘笔记会再了解

```
git checkout -- <file>...//撤销已修改文件的修改，文件暂存的内容不会被撤销
```

注：任何已提交的东西几乎都可以恢复。甚至那些被删除的分支中的提交或使用--amend覆盖的提交也能恢复。但是，任何没提交的东西丢失后很可能找不回来了。具体可以看Git内部原理-维护与数据恢复笔记

## 六、忽略文件

指忽略掉不需要纳入Git文件管理，也不希望出现在未跟踪文件列表里的文件。通常包括日志文件或编译是产生的临时文件。

实现操作：在需要忽略规则的目录下创建.gitignore文件（不管是否被Git跟踪都会执行该规则）。文件格式规范：1、所有空行或#开头的行都会被Git忽略2、可以使用标准的glob模式匹配，会递归的应用到整个当前目录及子目录3、匹配模式可以使用/开头防止递归4、匹配模式可以使用/结尾指定目录5、忽略指定模式外的文件或目录可以在模式前加上！取反

glob模式指shell所使用的简化的正则表达式。*号匹配零个或多个任意字符；[abc]匹配任意一个在方括号中的字符；？号只匹配任意字符；方括号中使用—分隔两字符，表示所有在这两字符范围内的都可以匹配。使用**表示匹配任意中间目录，如a/\*\*/z可以匹配a/z、a/b/z、a/b/c/z等。

![](image\Snipaste_2024-11-02_11-24-19.png)

https://github.com/github/gitignore，该链接有数十种项目和语言的.gitignore文件列表，可以直接拿来用

.gitignore文件只作用在其所在目录，该目录要被Git跟踪，不然Git检测不到里面的文件，里面的文件使用.gitignore过滤文件也没意义

## 七、查看已暂存和未暂存的修改

```
git diff [file] //查看当前已修改的所有文件/指定文件和暂存区的差异，即修改后还未暂存的变化内容，不会显示未跟踪的文件内容
git diff --staged/--cached //查看已暂存文件和最后一次提交的文件差异
```

git diff不包含最后一次提交与已暂存文件的差异，只包含已修改的文件内容，所以有时候文件全部暂存，运行git diff什么也没有

```
git difftool //使用外部diff工具比较差异，使用前需要配好外部差异工具
git difftool --tool-help//查看当前系统支持的Git Diff插件
```

config对应属性：diff.tool

该命令具体可以参考[git difftool 命令 | 菜鸟教程](https://www.runoob.com/git/git-difftool.html)

## 八、提交更新和跳过暂存区直接提交及补充或重命名上一次提交

```
git commit //启动文本编辑器提交输入说明并只将暂存区的修改提交 -v可以有更详细的修改内容提示 输入说明内容可以点击：Insert键，退出编辑器的方法：先ESC键，然后输入：进入命令行模式，之后再输入q或exit退出编辑器，退出编辑器后会丢弃掉注释，然后通过输入的说明生成一次提交，没有输入说明不会提交
```

可以添加-m直接将提交说明一并提交，如git commit -m "提示信息"

可以添加-a直接将所有已跟踪（已修改和已暂存）的文件暂存并提交，从而跳过git add操作。注意使用，避免把不需要的文件提交。

可以添加--amend重新提交，该选项会将暂存区的修改提交，如果自上次以来暂存区里并没有修改，那么快照不变，原来提交说明信息会被这次的覆盖，可以结合-a操作（不建议，理由跟上面一样）。理解：当需要对最后一次提交的补充时用到，该操作是完全用一个新提交替换掉旧提交，从效果上看，旧提交就好像没有过一样，不会出现在提交历史里，新提交会代替旧提交，提交的内容包括新旧提交

## 九、移除文件

要从Git中移除某个文件(被Git跟踪的文件)，可以手动删除，再git add到暂存区。

也可以直接使用:

```
git rm <file> //移除文件
```

如果要删除之前已修改过或已经放到暂存区的文件，就必须使用-f才能强制移除。Git的一种安全特性，防止误删到还未添加到快照的数据（即还没git commit后的数据），这样的数据不能被Git恢复。

如果想从Git仓库（即已被Git跟踪的状态）中删除，但想保留在工作目录中。即想让文件保留到磁盘中，但不想被git继续跟踪。可以使用--cached

git rm 后面还可以列出文件或目录，注：目录时需要加上-r才能移除。也可以使用glob模式，如：git rm log/\\\*.log，删除log目录下的所有.log文件，反斜杠表转义

## 十、移动文件或重命名

Git不像其他VCS系统，不会显示跟踪文件移动操作。如果在Git中重命名某个文件，仓库中存储的元数据并不会体现这是一次改名操作。但Git推断出发生的操作。

要在Git中对文件改名，执行：

```console
git mv file_from file_to //将文件移动到另一个地方
```

该命令相当于执行三条命令：mv file_from file_to ->git rm file_from->git add file_to

如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。两者的区别在于git mv是一条命令。使用其他工具重命名时，要git rm旧文件，git add 新文件。

## 十一、查看提交历史

```
git log//查看提交日志，会列出每个提交的SHA-1校验和、作者的名字和电子邮箱、提交时间及提交说明
```

### 11.1过滤输出内容（常用）

以下例子“”、=号可加可不加，但不加的话要空格隔开

-<n>，n可为任意整数，表示仅显示最近n条提交

--since或-after，仅显示指定时间之内/之后的提交，如git log --since=2.week，列出两周内的提交。该命令的格式丰富，可以是具体2008-01-15的具体某一天（这一天之后，不包这一天），也可以2 years 1 day 3 minutes ago的相对时间（这个时间段之内）。

--until或--before，仅显示指定时间之前的提交，该命令指具体某一天时包括这一天，其他对照--since或-after。

--author，仅显示指定作者的提交,如git log --author=frb，不能与--all-match一块，否则输出的是所有作者的提交

--committer,仅显示指定提交者的提交

--grep ,仅显示提交说明中包含指定字符串的提交

-S，仅显示匹配指定字符串修改（删除或添加）的提交，与--grep不同在于一个是对工作目录内容，一个是对提交说明。如：git log -S 1 ，匹配修改内容有1的提交，该例子参数不能加等号，可以加""号

--no-merges，不显示提交中所有MERGE合并操作的提交，--merges，只显示所有合并的提交

### 11.2设置输出格式：

添加-p或--patch，会显示每次提交的差异（按补丁的格式输出到控制台，即git diff的格式）。

添加--graph，该选项在旁以 ASCII 图形展示分支、合并历史，类似画图

\*\*添加--stat,显示有几个文件变了，总结性语句。简略的统计信息，没啥用

**添加--shortstat，总结性语句，相比--stat少了具体哪个文件修改显示

**--name-only，仅在提交信息后显示已修改的文件清单。

**--name-status，显示新增、修改、删除的文件清单，显示效果有点类似git status -s

**--abbrev-commit，仅显示 SHA-1 校验和所有 40 个字符中的前几个字符，相比git log只有SHA-1不一样

**--relative-date，相比git log使用较短的相对时间，如“2 weeks ago”

\*\*添加--pretty，使用不同默认格式显示提交历史，该选项有内置子选项，如oneline 一行显示、short、full、\*\*fuller、format等，例子：git log --pretty=oneline。不同选项展示的信息基本一致，但详细程度不同

**--oneline，--pretty=oneline --abbrev-commit合用的简写

\*\*其中format选项可以定制记录显示格式，命令例子：git log --pretty=format:"%h - %an, %ar : %s"，用法类似字符串中的占位符，：号两侧没有空格隔开

\*\*format常用选项：%H 提交的完整哈希值、%h提交的简写哈希值、%T树的完整哈希值、%t树的简写哈希值、\*\*%P父的完整哈希值、%p父提交的简写哈希值、%an作者的名字、%ae作者的电子邮箱、%ad作者修订日期（可以用--date=来定制格式）、 %ar作者修订日期（按多久以前的方式显示）、%cn提交者名字、%ce提交者的电子邮箱、%cd提交日期、%cr提交日期（距今多长时间）、%s提交说明

作者是实际修改的人，提交者是将代码提交到仓库的人。Git分布式会介绍两者差别。

## 十二、打标签

Git可以给仓库历史的某一个提交打上标签以示重要，通常会使用这个来标记软件发布节点，如v1.0，v2.0版本的软件。

```
git tag //列出标签（以字母顺序列出）
```

```
git rag -l/--list "匹配的内容（带有通配符的）"//查找满足匹配内容的标签
```

如果想要查询完整的标签列表，-l或--list可选。但是如果想要匹配标签名的通配模式，-l或--list是强制使用的

创建标签

Git支持两种标签：轻量标签和附注标签

轻量标签：对某个提交的引用

附注标签：存储在git数据库中的完整对象，可以被校验，其中包括打标签者的名字、电子邮件、日期时间和附注信息，并且可以使用GPG签名并验证。通常建议使用该标签，可以有具体的信息，如果只是想要用来当做临时标签或者不想保存附注标签会保存的信息时也可以使用轻量标签。

```
git tag -a 标签名 //创建附注标签，在命令的末尾加上指定提交的校验和或部分校验和能给该提交打上标签，不然默认是给最新的提交打标签，一个提交只能打一次标签，多打会提示失败，标签已存在
```

添加-m 说明信息，指定存储在标签中的信息，如果直接执行上面的命令创建辅助标签Git会启动编辑器要求输入信息，不输入退出添加标签的操作会失败（跟git commit一样）。

```
git tag <tagname> //创建轻量标签，不需要-m选项添加说明信息,只需要标签名字
```

```
git show 标签 //查看标签及对应的提交信息，有标签和提交的详细信息（轻量标签的话只有提交的信息）
```

```
git push <remote> <tagname> //推送标签到远程分支
```

一般，git push 操作不会将标签推送到远程仓库，创建完标签后需要显式地推送到服务器上

添加--tags可以一次性将所有远程仓库没有的标签全部推送到远程仓库，该选项不会区分轻量标签和附注标签，目前没有简单的选项能够选择只推送一种标签

```
git tag -d 标签名 //删除标签，和添加标签一样，远程仓库也需要显示推送
```

```
git push<remote>  :refes/tags/<tagname> //删除远程仓库标签的变体，含义：将：号前的空值推送到远程标签，从而高效的删除该标签
```

```
git push <remote> --delete <tagname> //删除远程仓库标签
```

```
git checkout <tagname> //查看某个标签所指的版本，如果有修改提交不推荐该命令，会让仓库处于分离头指针，跟git checkout 哈希值（校验和）一样
```

```
git checkout -b <newbranch> <tagname>//创建标签对应提交的新分支，如果有修改推荐使用该命令，不过一般不需要修改提交的话使用上面的命令就行
```

十三、Git 命令别名

Git不会在输入的时候就能判断出想要的命令，如果不想输入完整的Git命令或命令太长，可以给Git命令添加别名，使用Git命令时可以用别名替代

使用config文件给Git子命令命令添加别名，如git config --global alias.a "state -s" ，设置之后使用git a就相当于git status -s。注：别名设置只能除了git外的部分，Git会将别名替换为对应的命令，如果字符串有空格，需要加“”或' '号，不然只会将第一个串连续字符设置别名。可以使用git config --list查看属性。

如果想给Git外部命令设置别名，需要在命令前加！。如：git config --global alias.b "!gitk"
