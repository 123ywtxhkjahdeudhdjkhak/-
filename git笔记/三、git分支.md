Git处理分支十分轻量

Git完成一次完整提交（包括暂存操作)会创建三种对象，blob对象、树对象、和一个提交对象

GIt执行暂存操作时会给暂存的文件创建一个blob对象，该对象保存着当前文件版本的快照，同时Git会为文件计算校验和，用来引用该快照。暂存时会将其保存到Git仓库，并将校验和放到暂存区域等待提交。

(注：blob对象不包含文件名，如果多个文件的文件内容一致，或者修改后的文件内容Git仓库已经有该快照，哪怕是不同目录，都不会创建新的blob，都会在暂存区域添加一个新的引用，但引用的是同一个校验和。但要注意，如果有些内容重新生成，如果空格、换行这类内容有区别，也会生成新的blob，毕竟跟原先不完全一样了，校验和也就不一样了。原理猜测是暂存时会计算文件快照校验和，如果仓库中有就不会创建新的blob对象，加个指针引用就行，但之后提交的话tree对象会创建新的，不过如果出现一个暂存的全部文件修改后暂存然后又改回原来的继续暂存，这时候如果提交会失败，即使Git因上一次暂存生成新的blbo对象，因为暂存区域跟上次快照相同)

Git执行提交操作时会先计算每一个子目录的校验和，然后在Git仓库中基于这些校验和创建tree对象。然后会创建一个提交对象，会保存指向tree对象的指针、作者的姓名、邮箱、提交时输入的信息、及指向父对象的指针。首次提交产生的提交对象没有父对象，合并后的提交对象有多个父对象，一般的提交对象只有一个父对象。

<img src="image\Snipaste_2024-11-18_09-50-00.png" style="zoom:100%;" />

![](image\Snipaste_2024-11-18_11-26-37.png)

<img src="image\Snipaste_2024-12-02_09-03-14.png" style="zoom:75%;" />

## 分支创建

```
git branch <new branch> //创建新分支，但不会自动切换到新分支，不加任何参数的话会查看所有分支，具体可看分支管理
```

```
git checkout -b <new branch> //创建新分支，同时自动切换到新分支
```

Git分支的本质只是指向提交对象的可变指针，每一次提交分支指针都会自动向前移动。创建分支时只是在提交对象上创建了个新的指针，分支本质上是仅包含所指提交对象校验和（长度为40的SHA-1值字符串）的文件，创建一个新分支就相当于往一个文件里写入41个字节（40字符加1换行符）的数据，所以创建速度很快。

<img src="image\Snipaste_2024-12-02_09-07-03.png" style="zoom:75%;" />

可以使用git log --oneline --decorate查看分支情况。

## 分支切换

```
git checkout <branch> //切换分支
```

<img src="image\Snipaste_2024-12-02_09-43-08.png" style="zoom:75%;" />

HEAD特殊指针，该指针会指向当前所在分支（分支是指向提交对象的可变指针），如果指针移动了，该特殊指针也会跟着移动。切换分支本质就是将该指针切换到另一个可变指针，同时会将工作目录切换成该分支的版本，Git会自动添加、删除、修改文件以确保此时工作目录内容跟该分支指针指向的提交对象快照一样。

注：未跟踪的文件不会受影响，也就是新增的未跟踪文件切换分支后依旧会存在。切换时要保证分支处于干净的状态，即已跟踪文件无修改，暂存文件已提交，未跟踪文件不会影响分支切换。如果存在被跟踪文件修改了，但还没提交会被阻止切换，因为文件还没保存到提交快照中，如果切换了修改内容就没了。有一些方法可以绕过这个问题，即贮藏和修补提交。可以在贮藏和清理笔记中看到这两个命令。

可以使用git log --oneline --decorate --graph --all查看分支分叉情况

## 分支合并

```
git merge <branch> //合并分支，可以加-m后面输入说明信息(相当于给新创建的合并提交输入说明信息)，不输入的话Git会有默认说明信息，如果是情况一的快进操作就不需要因为没有产生新的提交，即使输入说明信息也不会在提交历史中
```

情况一：

当两个分支合并时，如果能顺着一个分支走下去能够到达另一个分支，那Git合并时只是简单将落后的指针向前移动（指针右移），这种情况没有需要解决的分歧，称为快进（fast-forward）。

<img src="image\Snipaste_2024-12-02_11-17-34.png" style="zoom:75%;" />

情况二：

分支合并有分叉，即不存在某一分支所在的提交是另一个分支所在提交的直接祖先。出现这种情况时，Git会使用两个分支所在提交的快照及共同祖先做一个简单的三方合并。无冲突的情况下会直接创建一个新的提交，并将当前分支指向该新的提交

<img src="image\Snipaste_2024-12-02_11-31-15.png" style="zoom:75%;" />

<img src="image\Snipaste_2024-12-02_11-32-29.png" style="zoom:75%;" />

情况三：

相比情况二多了冲突情况，即两个不同分支中对同一个文件的同一个地方进行了不同的修改，两个分支的该文件都相比共同祖先该地方内容不同。该情况下Git做了合并，但没有自动的创建合并提交对象，需要手动解决冲突之后才能继续合并。如：

![](image\Snipaste_2024-12-02_18-25-49.png)

格式为<<<<<<<,=======,>>>>>>>，以=======分隔两分支的差异内容。

为每个冲突文件解决冲突后使用git add 标记冲突已解决。可以使用git status 查看未合并（unmerged)状态的文件。

可以使用图形化工具进行合并，可参考高级合并笔记

## 删除分支

```
git branch -d <branch> //删除分支,如果分支还包含未合并的内容会删除失败，可以使用-D选项强制删除
```

## 分支管理

```
git branch //查看当前所有分支，*号后面的分支是当前分支
```

-v选项可查看当前所有分支及每个分子最后一次提交

--merged和--no-merged可以过滤掉已经合并和尚未合并到当前分支的分支（会检出当前分支，*号后面的是当前分支），可以给定一个分支参数查看指定分支的合并状态而不用检出该分支。如git branch --no-merged master表示查看还没合并到master分支的分支

## 远程分支

远程引用是对远程仓库的引用(指针)，包括分支、标签等。

```
git ls-remote <remote> //查看完整的远程引用列表，可以查看跟踪的分支和标签
```

```
git remote show <remote> //查看指定服务器的分支跟踪情况
```

远程跟踪分支是远程分支状态的引用，是无法移动的本地引用。当与远程仓库连接并拉取数据后Git才会移动这些分支，来反映远程仓库的状态。类似书签，标记着最后一次连接远程仓库的位置。这些分支以<remote>/<branch>形式命名。

<img src="image\Snipaste_2024-12-11_11-20-40.png" style="zoom:90%;" />

<img src="image\Snipaste_2024-12-11_11-20-53.png" style="zoom:90%;" />

当运行git fetch <remote>后拉取远程仓库的数据，同时Git会自动移动跟踪分支的指针，该命令不会自动合并，可用git pull 拉取后自动合并。使用git remote add 可以添加一个新的远程仓库到当前项目，GIt基础有该命令的笔记。

<img src="image\Snipaste_2024-12-11_11-28-36.png" style="zoom:90%;" />

<img src="image\Snipaste_2024-12-11_11-29-02.png" style="zoom:90%;" />

上图由于新添加的仓库是原先仓库的子集，所以执行完git fetch 命令后不会拉取数据而是会设置远程跟踪分支。

## 分支推送

本地的分支不会自动推送到远程仓库，必现显示地将本地分支推送到可写入的远程仓库。

```
git push <remote><branch> //推送分支，可将本地分支推送或分支修改的内容进行推送
```

git push origin serverfix 该命令完整形式 git push origin refs/heads/serverfix:refs/heads/serverfix，refs/heads可看Git内部原理笔记，也可git push origin serverfix:serverfix，意思都是推送本地的serverfix分支作为远程仓库的serverfix分支，可以通过这种格式来推送本地分支到一个命名不相同远程分支。

## 跟踪分支

跟踪分支是与远程分支有直接关系的本地分支。如果在一个远程分支上输入git pull，Git能自动识别去哪个服务器抓取、合并到哪个分支。从一个远程分支上检出一个本地分支后会自动创建跟踪分支，其跟踪的分支又称上游分支。当克隆一个仓库时，会自动创建一个跟踪上游分支origin/master的master跟踪分支。

```
git checkout -b <branch>  <remote>/<branch> //检出分支（如果不存在就会自动创建）并去跟踪远程分支
```

快捷方式：

```
git checkout --track <remote>/<branch> //检出跟踪指定远程分支的跟踪分支
```

更快捷：

```
git checkout <branch>//切换到指定分支，如果该分支不存在，且刚好只有一个与之匹配的同名远程分支，那个就会自动创建一个跟踪分支
```

注：如果想要本地跟踪分支和远程分支不同名，可以使用第一个方式

设置一个已有的本地分支跟踪刚刚拉取的远程分支，或者修改当前跟踪分支正跟踪的远程分支，可以在任意时间使用-u 或 --set-upstream-to选项显示运行git branch来显示设置，如:

```
git branch -u <remote>/<vrabch> //切换当前跟踪的远程分支
```

设置好跟踪分支后，可以使用@{upstream}或@{u}引用远程分支。如master跟踪分支的远程分支给origin/master，则git merge origin/master 等于git merge @{u}命令

```
git branch --vv //查看本地分支和远程分支情况，可以看到本地分支是否跟踪某个远程分支，对策落后或领先
```

```
git fetch --all; git branch --vv //获取最新的本地分支和远程分支情况，较上一个命令多了拉取最新数据
```

## 分支拉取

```
git fetch //只会拉取数据并等待合并，不会改变工作目录的内容
```

```
git pull //与git fetch不同，会拉取并自动进行合并远程分支数据到跟踪分支
```

## 删除远程分支

如果远程分支的工作已完成并合并到其他分支，可以将该远程分支从服务器中删除

```
git push <remote>  --delete <branch> //删除远程分支
```

该命令会从服务器中移除该分支指针，但会保留一段时间，直到垃圾回收运行，所以如果不小心删除后也短时间内可以恢复

## 分支变基

Git中整合不同分支的方式主要有两种，合并和变基。

```
git rebase <branch> //基于目标分支变基
```

合并会将两个分支的最新快照以及两者共同祖先进行三方合并，合并后的结果会生成一个新的快照并提交

<img src="image\Snipaste_2024-12-31_16-41-41.png" style="zoom:80%;" />

变基原理：提取当前相较于当前和目标分支共同祖先的历史修改提交并存为临时文件，然后将当前分支移到目标分支所指针，最后将临时文件的修改依序应用。作用将当前分支的所有修改都移到另一个分支。相当于基于两个分支的共同祖先提取当前分支的所有补丁和修改并将补丁作用到目标分支然后提交并将当前指针位置移到该提交，但原先目标分支指针的位置并没有移动，可通过merge合并

<img src="image\Snipaste_2024-12-31_16-54-41.png" style="zoom:80%;" />

上图master合并experiment分支后如下图

<img src="image\Snipaste_2024-12-31_17-00-19.png" style="zoom:80%;" />

--onto选项可以指定要操作的提交范围

两种情况：

1、指定起始提交，后面只跟两个分支，前是目标分支，后是起始提交

2、指定起始提交和终止提交，后面跟三个分支，前是目标分支，中是起始提交，后是终止提交，即会将当前分支从起始提交到终止提交的提交应用到目标分支

![](image\Snipaste_2024-12-31_17-07-26.png)

如上使用git rebase --onto master server client（除了分支也可以是某次提交），结果如下

![](image\Snipaste_2024-12-31_17-16-58.png)

```
git rebase <basebranch><topicbranch> //将后分支变基到前分支，可以不用切换到对应分支再切回来
```

注：变基操作的目的只为了让提交历史清晰，一条线，只适合提交只在自己仓库的情况。

原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作

将本地修改提交到远程仓库后再执行变基操作的后果可查看Git官方文档变基后面的例子。
