## 一、运行时权限

定义：由于早期应用权限存在滥用的现象，就是用不到的权限也会被申请，其中还有威胁到用户隐私和安全的权限，所以android6.0后加入了运行时权限的功能，android将所有权限分成两类，一类是不会威胁到用户安全和隐私的普通权限，另一类是会威胁到用户隐私和安全的危险权限，对于不会威胁到用户安全和隐私的普通权限系统会自动授权，对于可能会威胁到用户设备安全和隐私的危险权限需要在软件使用过程中再对该类危险权限申请授权，对于这部分权限申请必须由用户点击授权才行，否则程序无法使用相应的功能。就算拒绝了这个权限，也可以继续使用软件的其他功能，而不像早期那样在安装软件时就一次性授予所有申请的权限。

使用场景：6.0以上系统使用危险权限时

实现：第一步先检查用户是否已经授权，通过ContextCompat类中的checkSelfPermission静态方法，这个方法有两个参数，第一个Context对象，第二个是具体的权限名，然后返回值跟PackageManager.PERMISSION_GRANTED做比较，就是判断返回值是否为0，如果为0那就说明权限用户已授予，授予的话就执行相应的功能，如果没有那就没授予，需要调用ActivityCompat中的requestPermissions()静态方法来向用户申请，这个方法有三个参数，第一个参数是activity对象，第二个参数是String数组，将需要申请的权限放到数组里就行，第三个参数是请求码，保证唯一值就行。调用完requestPermissions()方法后，系统会弹出一个权限申请的对话框，然后用户可以选择同意或拒绝我们的权限申请，不论哪种结果，最终都会回调到onRequestPermissionsResult()方法中，该方法有三个参数，第一个是之前申请参数是的请求码，可以用来判断当前返回的是哪次权限申请，第二个参数是String权限数组，第三个是授权的结果，结果会封装到该方法的grantResults int数组参数中，根据数组中的值是否为0判断权限是否已授予，然后再执行响应的操作，比如未授予的话弹出授权失败的弹窗，已授予的话执行相应的功能。当这个权限被授予后，就意味着该应用获得这个权限，后续不会再申请，除非用户在系统设置里取消授权。

二、内容提供器

定义：内容提供器主要用于在不同应用程序间实现数据共享的功能，它允许一个程序访问另一个程序的数据，同时还能保证被访数据的安全性。不同于早期文件存储和SP存储的两种全局读写操作模式，内容提供器可以选择哪部分数据进行共享，从而保证隐私数据不会被泄露。有两种用法：第一种是使用现有的内容提供器来读取和操作相应应用程序的数据，另一种是创建自己的内容提供器来给外部应用程序提供访问内部数据的接口。

使用场景：需要进行不同应用程序间数据共享时

实现：

第一种用法实现：想要访问内容提供器中共享的数据，就一定要使用ContentResolver类中，Content类中可以通过getContentResolver()方法获取该类的实例，ContentResolver类中提供一系列用于CRUD的方法。与数据库中的CRUD不同，ContentResolver中CRUD不接收表名参数，而是使用一个Uri参数替代，内容Uri给内容提供器的数据建立了一个唯一的标识符，该Uri由两部分组成，authority和path，authority用来区分不同应用程序的，通常为避免冲突会采用程序包名来命名，path则是用于区分同一应用程序不同表，通常使用资源路径命名，主要有两种，以路径结尾，表示期望访问该表全部数据，以id结尾，表期望访问该表相应id的数据，然后将authority和path两部分组合，在头部加上content协议声明。在得到对应的uri字符串后需要解析成uri对象才能作为参数传入，通常使用Uri类中的parse()静态方法，这个方法只有一个uri字符串参数。之后其他操作就跟数据库的CRUD方法调用类似。不过有些数据的访问还需要在AndroidManifest.xml文件中申请相应的权限。

第二种用法：创建自己的内容提供器。首先创建一个类去继承ContentProvider类然后在清单文件中声明，并指定authorites属性指定当前提供器的authority，创建的类需要实现这个ContentProvider类中的6个抽象方法，onCreate()方法，初始化内容提供器的时候调用，只有当存在ContentResolver尝试访问程序中的数据时，内容提供器才会被初始化，通常在这个方法中完成对数据库的创建和升级等初始化操作，返回true表示初始化成功，返回false则表示失败。4种CRDU操作的方法参数跟数据库一样，CRUD的实现是使用数据库存储操作，不一样在于使用uri参数用于确定操作的是哪张表，与UriMatcher类匹配相应的操作。getType()只有一个uri参数，与UriMatcher类匹配相应的操作，用于根据该参数返回相应的MIME类型字符串，该MIME字符串主要由3部分组成，必须以vnd开头，如果内容uri以路径结尾，则后接android.cursor.dir/，如果以id结尾，则后接android.cursor.item/，最后接上vnd.<authority>.<path>。前面说的借助UriMatcher类实现匹配内容URI的功能，通常会在自定义的内容提供器的静态代码块去创建一个该类的实例，然后使用该类中提供一个addURI()方法，这个方法有三个参数，分别将authority、path和一个自定义int类型码，path可以使用通配符匹配一类id的资源，如*号可以匹配任意长度的任意字符，#号可以匹配任意长度的数字。这样，当调用UriMatcher的match方法时，将Uri对象作为参数传入后，就会返回和这个uri匹配的自定义int类型码，用于在前面实现的CRUD和getType中匹配相应操作。由该自定义的内容提供器可以知道通过Uri的限制访问限制外部程序访问的操作从而实现用户数据隐私保护。

