## 一、异步消息处理

原因：和其他的GUI库一样，Android中的UI是线程不安全，如果想要更新应用程序中的UI元素，则必须在主线程中进行，否则就会出异常。

异步消息处理机制：Android中的异步消息处理主要由4部分组成：Message、Handler、MessageQueue和Loopper。其中Message是线程之间传递的消息，可以在内部携带少量的信息。Handler是用来发送和处理信息的，发送消息通常由使用该类中的sendMessage()方法发送Message实例，发送的信息经过一系列地辗转处理后最终会传递到Handler的handleMessage()方法中。MessageQueue是消息队列，主要用于存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只会有一个MessageQueue对象。Looper是每个线程中MessageQueue的管家，调用Looper的loop方法后就会进入到一个监听MessageQueue的无限循环中，每当MessageQueue中存在消息，就会将它取出，并回调dispatchMessage()方法传递到关联的Handler的handMessage()方法中。

实现：通过匿名内部类的方式创建一个Handler的对象，重写父类的handleMessage()方法，该方法有一个Message参数，通过该Message中的信息执行对应的操作。创建一个Message(可空参构造)对象，然后调用该对象的成员变量或方法设置信息，调用前面创建的Handler对象中的sendMessage()方法将这条Message对象发送出去，之后这条信息会被添加到MessageQueue的队列中等待被处理，Looper会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler中的handleMessage()方法中对它进行处理，该方法会根据Message中的信息执行对应的操作。此时的handleMessage方法是在主线程当中运行的，所以可以在这里进行UI操作。创建Handler时如果不指定关联则会自动关联到创建当前对象的线程，子线程中默认没有Looper，如果在子线程中直接创建不指定关联Loopper的Handler会报错，想要在子进程中创建Handler则需要使用带参的Handler去指定关联的Lopper或如果想要绑定到当前子线程则需要在创建Handler前先执行 Looper.prepare()方法创建Lopper，最后调用Looper.loop()启动Looper 的消息循环。

## 二、服务

定义：服务是android中实现程序后台运行的解决方案，适合不需要和用户进行交互且长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开另一个应用程序，服务仍能保持正常运行。服务不是运行在独立的进程中，而是依赖于创建时所在的应用程序进程，当应用进程被杀掉时，所有依赖于该进程的服务也会停止运行。服务不会自动开启线程，所有的代码都默认运行在主线程中。

使用场景：不需要和用户交互且长时间运行的后台任务

实现：创建一个继承Sevice的子类，实现onBInd(Intent intent)抽象方法，然后在清单文件中注册声明。重写onCreate()、onStartCommand()、onDestroy()3个方法。其中onCreate()方法会在服务创建时调用，onStartCommand()方法会在每次服务启动时调用，onDestroy()方法会在服务销毁时调用。如果希望服务启动后就立即执行的操作可以将逻辑写到onStartCommand()方法中。使用Context类中的startService()和stopService()启动和停止服务，都需要传入一个Intent参数，停止服务也可以调用Service自身的stopSelf()方法，启动服务后如果不主动停止，服务就会一直运行。使用startService()方法启动服务后，如果服务还没创建，则会调用onCreate()和onStartCommand()方法，若服务已经创建，则只会调用onStartCommand()方法。前面的启动服务的方法操作都在Service中，如果想要与Service通信，可以使用Context类中的bindService()和unbindService()方法。想要使用bindService()方法启动服务，需要重写onBind(Intent)方法，返回一个IBinder对象，该对象用于客户端和服务通信，通常是在服务中定义一个实现IBinder接口的内部类，然后创建该类的实例并返回给客户端。之后在客户端创建一个ServiceConnection的子类，然后重写onServiceConnected()和onServiceDisconnected()方法，这两个方法分别会在服务成功绑定以及解除后调用。当客户端调用bindService()方法绑定服务时传入Intent、ServiceConnection实例、标记位三个参数，如果服务还没创建，会调用onCreate()方法，如果服务还没被使用bindService()方法绑定过，会调用onBind(Intent)方法，这个方法返回的IBinder对象会传到ServiceConnection对象中的onServiceConnected方法中，可以在这里通过IBinder与Service进行通信。如果服务已经被bindService绑定过，则不会调用onBInd(Intent)方法，而是会直接把IBinder对象传递给后来增加的客户端。

生命周期：Android中一个服务在一个进程中只会存在一个实例，onCreate()方法只会在服务创建时调用。一个服务不管被startService()或bindService()方法启动或绑定多少次，只需要调用一次stopService()或unbindService()方法就可以停止服务。当一个服务同时被startService()和bindService()方法启动和绑定时，这种情况要同时调用stopService()和unbindService()方法服务才能被销毁，onDestroy()方法才会执行。

## 三、前台服务

定义：服务基本都是后台运行的，但是这样服务的系统优先级比较低，当系统内存不足时，就会回收掉正在后台运行的服务。如果希望服务能一直运行，而不会由于内存不足的原因导致被回收，可以使用前台服务。前台服务和普通服务最大区别在于前台服务会有一个正在运行的图标在系统状态栏显示，下拉状态栏后可以看到更详细的信息，类似于通知的效果。

实现：在Service类onCreate()方法中调用startForeground()方法就会让当前服务变成一个前台服务，并在状态栏显示出来，该startForeground()方法接收两个参数，第一个是通知id，第二个是Notification对象。

## 四、IntentService

定义：由于服务的代码都是在主线程运行的，主线程不能执行耗时操作，否则会出现ANR异常，所以通常如果需要在服务中执行耗时操作，则需要开启一个子进程。如果希望当子进程的代码执行完后就停止服务也可以在子进程中执行stopSelf()方法。为了简单地创建一个异步的，会自动停止的服务，Android专门提供了一个IntentService类。

实现：定义一个继承IntentService的子类，实现该类中onHandleIntent()抽象方法，在这个方法中可以执行一些耗时操作，因为该方法是在子线程中调用的。子类中提供一个无参构造方法，在方法中调用父类的有参构造，因为IntentService类中没有无参构造方法。启动该服务的方法和正常方式一样，不过该服务启动执行完后会自动停止。